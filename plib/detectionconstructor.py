# -*- coding: utf-8 -*-
"""
Created on Wed Feb 24 14:45:40 2021

@author: Thomas
"""
# detection constructor

############### notes #######################################
## Reed-Solomon (or other?) detection scheme, turn into dicts

### prime powers = allowed numbers of channels/ colours

# k	OEIS	prime kth powers
# 1	A000040	2, 3, 5, 7, 11, 13, 17, 19, 23, ...
# 2	A001248	4, 9, 25, 49, 121, 169, 289, 361, ...
# 3	A030078	8, 27, 125, 343, 1331, 2197, 4913, ...
# 4	A030514	16, 81, 625, 2401, 14641, 28561, 83521, ...
# 5	A050997	32, 243, 3125, 16807, 161051, 371293, ...

#z = mod(quotient(g/dc^n),dc)
#d = mod(quotient(g/dc^3),dc)
#c = mod(quotient(g/dc^2),dc)
#b = mod(quotient(g/dc^1),dc)
#a = mod(g, dc)
#number of rounds (#r)
#number of dyes (#d)
############## notes end ####################################


import pandas as pd
import numpy as np


################## load files for code testing, should be moved to main ################################
#dyes = pd.read_csv(r'C:\Users\Thomas\Documents\Python_and_R\inputdata\dyes.csv', header=0)['Sequence']
#barcodes = pd.read_csv(r'C:\Users\Thomas\Documents\Python_and_R\cDNA_padlocks.csv', header=0)['Barcode']
#probes = pd.read_csv('myprobes.csv', header=0)
## get list of all gene symbols from NCBI
#ncbirecords = pd.read_csv(r'C:\Users\Thomas\Documents\Python_and_R\gene_result.txt', header=0, sep='\t')    
## remove duplicates (if there are any)
#symbols = ncbirecords['Symbol'].unique() # this took minutes..
#symbols = symbols[~np.isnan(symbols)] #returns TypeError
## remove NULL/ NAs if there are any
#symbols = symbols[pd.isnull(symbols) == False] #  note: 'None' is considered a null value in object arrays.
###########################################################################################################################

##### load default symbol-barcode and dye look-up-tables in case none are provided by user or probecontructor module
## this can be supplied by user or generated by probeconstructor module (expects symbols in first column, barcode-sequences in second column)
barcode_lut = pd.read_csv('default_barcodes.csv', header=0).iloc[:,0:2] # remember iloc!!
## this is supplied by user
dye_lut = pd.read_csv('default_dyes.csv', header=0)['Sequence']## these need to be complementary-reversed!

## functions ##

def revcomps(seqs):
    '''generates reverse complementary seqs from DNA/RNA pd.Series object, returns pd.Series'''
    rcdict = {'A':'T','T':'A','G':'C','C':'G'}
        #seq = 'TTGCCACT'
    seqrclist = []
    for seq in seqs:
        #rcseq = "".join(rcdict.get(base, base) for base in seq)[::-1]
        seqrclist.append("".join(rcdict.get(base, base) for base in seq)[::-1])
    return pd.Series(seqrclist) 

## could use str.maketrans method:
    ## seq = 'CCATTAGT'
    ## conversiontable = str.maketrans('ATCG','TAGC')
    ## seq.translate(conversiontable)[::-1] ##gets revcomp

def makedetection(colors=7, rounds=10, wordlimit=30000, barcode_lut=barcode_lut, dye_lut=dye_lut): #easier with some defaults, (expects symbols in first column, barcode-sequences in second column)
    '''generates bridge detection probes, returns two DFs:
        bridge probes and index (replace with symbols) x round LUT'''
    #colors=7; rounds=7
    approvedppowers = [3, 5, 7, 11, 13, 17, 19, 23, 9, 25, 49, 121, 169, 289, 361, 27, 125, 343, 1331, 2197, 4913, 81, 625, 2401, 14641, 28561, 83521, 243, 3125, 16807, 161051, 371293]
    if colors not in approvedppowers:
        print('\n Number of colors either not an ODD prime power or a LUDICROUSLY high number. Try again!')
    elif colors > 7:
        print('\n Up to 7 colors/ channels are currently supported. Try again!')
    else:
        print(f'\n {colors} is an approved prime power')
        #numberchannels = colors # number of channels: needs to be a prime power, eg 5 = 3**1, 5**1, 7 = 7**1, 9 = 3**2 and 32 = 2**5 are prime powers (and all prime numbers, 1 is not counted)
        channels = np.arange(colors)
        codewords = np.arange(symbols.size + colors) # create as many codewords as there are symbols in provided file
        #codewords = codewords[:wordlimit] #limit wordsize
    
        codewords = np.arange(wordlimit + colors) # create as many codewords as there are genes
    
        dc = colors  # number of channels: needs to be a prime power, eg 5 = 3**1, 5**1, 7 = 7**1, 9 = 3**2 and 32 = 2**5 are prime powers (and all prime numbers, 1 is not counted)
        a = np.floor_divide(codewords, dc**0) % dc #since anynumber**0 = 1
        b = np.floor_divide(codewords, dc**1) % dc
        c = np.floor_divide(codewords, dc**2) % dc
        d = np.floor_divide(codewords, dc**3) % dc
        e = np.floor_divide(codewords, dc**4) % dc
        f = np.floor_divide(codewords, dc**5) % dc
        g = np.floor_divide(codewords, dc**6) % dc
       

## now compute channel for every round and codeword (ie barcoded gene symbol)   
        rvector = np.arange(rounds) #counts from 0

        charr  = []
        for r in rvector:
            #print(r)

           # ch = ((f*(r^5)) + (e*(r^4)) + (d*(r^3)) + (c*(r^2)) + (b*r) + (a)) % dc ##note: discard rows until dc-1 , mind the brackets around r**n
            ch = ((g*(r^6)) + (f*(r^5)) + (e*(r^4)) + (d*(r^3)) + (c*(r^2)) + (b*r) + (a)) % dc
            charr.append(ch)
            chstack = np.stack(charr, axis=1)[dc:]  #need to start at dc! 
 
## load barcode sequences, dye-probe sequences, symbol-barcode LUT from csv as df

        rcdyeseq = revcomps(dye_lut)
        chstackdf = pd.DataFrame(data=chstack)
        duplicate = chstackdf.duplicated()
        if any(duplicate == True):
            print('duplicate codes found')
         
        else:    
            print('no duplicate codes found')
            
        chstackdf['duplicate'] = duplicate
        channels = np.unique(chstack[0]) ## get 'set'of available channels from codeword array
## assign rcdye sequence and codeword (gene symbol) number
        rcdyedict = dict(zip(channels,rcdyeseq))
        bcseqdict = dict(zip(chstackdf.index, barcode_lut['Barcode']))
  
        ch_decoded = chstackdf.applymap(lambda d: rcdyedict.get(d) + bcseqdict.get(d) + rcdyedict.get(d))#note: use applymap instead of apply for entire df
        ch_decoded['duplicate'] = duplicate
        ch_decoded.to_csv('bridgeprobes.csv', index=False)
        chstackdf.to_csv('rscode.csv', index=False)
        return ch_decoded, chstackdf ##write to csv in main?


## done
## test this
# mybridgeprobes, mycode = makedetection(5,10,1000) #only works for colors up to 7
